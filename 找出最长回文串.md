## 找出最长回文串 ##
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：
> 输入: "babad"
> 
> 输出: "bab"
> 
> 注意: "aba" 也是一个有效答案。

示例 2：

> 输入: "cbbd"
> 
> 输出: "bb"
# 代码演示 #

    //第一种方式，暴力破解 [O(n3)]
    string longestPalindrome(string s) 
    {
        int maxlen = 1;
        int len = s.size();
        int start = 0;
        for(int i = 0; i < len; i++)
        {
            for(int j = i + 1; j < len; j++)
            {
                int tmp1 = i;
                int tmp2 = j;
                while(tmp1 < tmp2 && s[tmp1] == s[tmp2])
                {
                    tmp1++;
                    tmp2--;
                }
                
                if(tmp1 >= tmp2 && maxlen < j -i + 1)
                {
                    maxlen = j - i + 1;
                    start = i;
                }
            }
        }
        return s.substr(start,maxlen);
    }
		
    //第二种方式，动态规划 [O(n2)]
    //设标志数组flag[j][i] 表示在字符串中从j到i的位置是否为回文，如果是为true，不是则为false
    string longestPalindrome(string s) 
    {
        int len = s.size();
        int start = 0;
        int maxlen = 1;
        bool flag[1000][1000];
        
        for(int i = 0; i < len; i++)
        {
            for(int j = 0; j <= i; j++)
            {
                if(i - j < 2)
                {
                    flag[j][i] = (s[j] == s[i]); //如果是相邻的两个元素，或者是自身比较，则直接比较是否为回文
                }
                else
                {
                    flag[j][i] = (s[j] == s[i] && flag[j + 1][i - 1]);//如果第j个位置和第i个位置的元素相同，且标志数组中j+1到i-1的字符串是回文，则从j到i的字符串也为回文
                }
                
                if((flag[j][i]) && maxlen < i - j + 1)//更新maxlen和start
                {
                    maxlen = i - j + 1;
                    start = j;
                }
            }
        }
        return s.substr(start, maxlen);
    }
    //中心法
    string longestPalindrome(string &s)
    {
    const int len = s.size();
    int maxlen = 1;
    int start = 0;

    for(int i = 0; i < len; i++)//求长度为奇数的回文串
    {
        int j = i - 1, k = i + 1;
        while(j >= 0 && k < len && s.at(j) == s.at(k))
        {
            if(k - j + 1 > maxlen)
            {
                maxlen = k - j + 1;
                start = j;
            }

            j--;
            k++;
        }
    }

    for(int i = 0; i < len; i++)//求长度为偶数的回文串
    {
        int j = i, k = i + 1;
        while(j >= 0 && k < len && s.at(j) == s.at(k))
        {
            if(k - j + 1 > maxlen)
            {
                maxlen = k - j + 1;
                start = j;
            }

            j--;
            k++;
        }
    }
    return s.substr(start, maxlen);
}


	


